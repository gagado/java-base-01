 跳跃表：
 * 高效的查找算法： 有序数组   二叉查找数   平衡二叉树   跳跃表
 * 跳跃表： 缺点是存在一定的数据冗余，达到以空间换时间的目的
 * 特征：
 *      1、一个跳跃表应该有若干个层（Level）链表组成；
 *      2、跳跃表中最底层的链表包含所有数据； 每一层链表中的数据都是有序的；
 *      3、如果一个元素 X 出现在第i层，那么编号比 i 小的层都包含元素 X；
 *      4、第 i 层的元素通过一个指针指向下一层拥有相同值的元素；
 *      5、在每一层中，-∞ 和 +∞ 两个元素都出现(分别表示 INT_MIN 和 INT_MAX)；
 *      6、头指针（head）指向最高一层的第一个元素；
 */
 ● 空间唤时间
 ● 可以实现二分查找的有序链表
 ● 可以创建多级索引
 ● 时间复杂度 = 索引的高度 * 每层索引遍历元素的个数
 ● 每多少个节点抽取出一个节点建立索引
 ● 跳表是通过一个随机函数来维护这个平衡的

 时间复杂度: log(n)

冒泡排序
选择排序
插入排序


快速排序：
1、确定一个基准值
2、确定左边的下标，从左边的数组下标往后遍历（while），找到第一个大于基准值的元素坐标停止
3、确定右边的下标，从右边的数组下标往前遍历（while），找到第一个小于基准值的元素坐标停止
4、对这两个数组下下标交换位置
5、递归调用


归并排序：合并两个有序数组
1、找到中间索引 mid
2、递归拆分数组（0 - mid）
3、递归拆分数组（mid + 1, arr.length -1）
4、合并两个有序数组


二叉树：
每个结点最多2棵子树，没有其它限制了

满二叉树：
除最后一层无任何子节点外，每一层上的所有结点都有两个子结点（两颗子树）

完全二叉树：
完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树

二叉搜索树：（该节点的左子树都小于该节点，右子树都大于该节点）
若其左子树存在，则其左子树中每个节点的值都不大于该节点值。
若其右子树存在，则其右子树中每个节点的值都不小于该节点值。

平衡二叉树：
该节点的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。

红黑树和平衡二叉树的区别
1.红黑树放弃了追求完全平衡,追求大致平衡,在与平衡二叉树的时间复杂度相差不大的情况下,保证每次插入最多只需要三次旋转就能达到平衡,实现起来也更为简单。
2.平衡二叉树追求绝对平衡,条件比较苛刻,实现起来比较麻烦,每次插入新节点之后需要旋转的次数不能预知。

平衡二叉树：
LL的意思是向左子树（L）的左孩子（L）中插入新节点后导致不平衡，这种情况下需要右旋操作，而不是说LL的意思是右旋，后面的也是一样。
右旋转：自己变为左孩子的右孩子,自己的左孩子的右孩子变为自己的左孩子
一般有4中情况：
LL(右旋) RR(左旋) LR(先右旋再左旋)  RL(先左旋再右旋)


红黑树：
1、每个节点或者是红的或者是黑的
2、根节点是黑的
3、每个叶子节点都是黑色的
4、如果一个节点是红色的，那么他的子节点都是黑色的
5、对于每一个节点来说，从该节点到其子孙节点的所有路径上包含相同数目黑节点
每次插入的节点都是黑色的

优先考虑祖孙三代：
父节点是黑色的:
    不用调整
父节点是红色的:
    1、叔叔节点是空的，旋转加变色
    2、叔叔是红色，父节点加叔叔节点变成黑色，祖父节点变为红色
    3、叔叔是黑色，旋转加变色


堆：
● 堆是一个完全二叉树。
● 常常用一个数组实现。
● 堆中选任一节点A，它的左右子节点的值都大于A的值（小根堆），或者左右子节点的值都小于A的值（大根堆）

大顶堆的构建过程：
1. 插入一个元素
2. 生成一个node节点
3. 将节点放入数组的最后一个索引下面
4. 向上筛选
  a. 求出父节点的坐标
  b. 将新增的节点定义为一个临时变量
  c. 拿新增节点和他的父节点进行比较,如果父节点小于新增节点的话
  d. 新增节点和父节点换位置
  e. 更新索引
  f. 求新的父节点的索引
  g. while循环直到不符合条件

若数组中的节点的索引为x：
    它的父节点的下标为(x-1)/2
    它的左子节点的下标为2*x+1
    它的右子节点的下标为2*x+2

堆排序：
1、将堆顶元素和最后一个元素交换位置，则最后一个元素就是最大值或最小值。
2、将其他的元素重新构建成一个大顶堆或者小顶堆。


图：
DFS  深度优先搜索 通过栈来实现
 规则一: 如果可能，访问一个邻接的未访问顶点，标记它，并把它放入栈中。
 规则二: 当不能执行规则一时，如果栈不空，就从栈中弹出一个顶点。
 规则三: 如果不能执行规则一和规则二，就完成了整个搜索过程。
BFS  广度优先搜索 通过队列来实现
 规则一: 访问下一个未来访问的邻接点（如果存在），这个顶点必须是当前顶点的临界点，标记它，并把它插入到队列中
 规则二: 如果因为已经没有未访问顶点而不能执行规则1，那么从队列头取一个顶点（如果存在），并使其成为当前顶点
 规则三: 如果因为队列为空而不能执行规则2，则搜索结束



b+树：
